Rudolf and the Ball Game

Rudolf and Bernard decided to play a game with their friends. ğ‘› people stand in a circle and start throwing a ball to each other. They are numbered from 1 to ğ‘› in the clockwise order.

Let's call a transition a movement of the ball from one player to his neighbor. The transition can be made clockwise or counterclockwise.

Let's call the clockwise (counterclockwise) distance from player ğ‘¦1 to player ğ‘¦2 the number of transitions clockwise (counterclockwise) that need to be made to move from player ğ‘¦1 to player ğ‘¦2. For example, if ğ‘›=7 then the clockwise distance from 2 to 5 is 3, and the counterclockwise distance from 2 to 5 is 4.

Initially, the ball is with the player number ğ‘¥ (players are numbered clockwise). On the ğ‘–-th move the person with the ball throws it at a distance of ğ‘Ÿğ‘– (1â‰¤ğ‘Ÿğ‘–â‰¤ğ‘›âˆ’1) clockwise or counterclockwise. For example, if there are 7 players, and the 2nd player, after receiving the ball, throws it a distance of 5, then the ball will be caught by either the 7th player (throwing clockwise) or the 4th player (throwing counterclockwise). An illustration of this example is shown below.


#include <bits/stdc++.h>
using namespace std;


int main() {
    int t;
    cin>>t;
    while(t--){

        int n, m, x;
        cin>>n>>m>>x;

        queue<int> q;

        q.push(x);
        vector<int> ans(n+1, 0);
        int count = 0;

        for(int i=0; i<m; i++){
            int dis;
            char c;
            cin>>dis>>c;
            int size = q.size();
            unordered_map<int, int> mp;
            for(int j=0; j<size; j++){
                int val = q.front();
                q.pop();
                int newDist;
                if(c == '?'){
                    newDist = (val + dis)%n;
                    if(mp.find(newDist) == mp.end()){
                        q.push(newDist);
                        mp[newDist] = 1;
                    }
                    
                    if(m-1 == i && ans[newDist] == 0){
                        count++;
                        ans[newDist] = 1;
                    }
                    newDist = (n + val - dis)%n;
                    if(mp.find(newDist) == mp.end()){
                        q.push(newDist);
                        mp[newDist] = 1;
                    }
                    if(m-1 == i && ans[newDist] == 0){
                        count++;
                        ans[newDist] = 1;
                    }

                }
                else if(c == '0'){
                    newDist = (val + dis)%n;
                    if(mp.find(newDist) == mp.end()){
                        q.push(newDist);
                        mp[newDist] = 1;
                    }
                    if(m-1 == i && ans[newDist] == 0){
                        count++;
                        ans[newDist] = 1;
                    }
                }
                else {
                    newDist = (n + val - dis)%n;
                    if(mp.find(newDist) == mp.end()){
                        q.push(newDist);
                        mp[newDist] = 1;
                    }
                    if(m-1 == i && ans[newDist] == 0){
                        count++;
                        ans[newDist] = 1;
                    }
                }
            }
        }


        cout<<count<<endl;
        for(int i=1; i<=n; i++){
            if(ans[i] == 1){
                cout<<i<<" ";
            }
        }
        if(ans[0] == 1){
            cout<<n;
        }

        cout<<endl;
    }
    return 0;
    
}