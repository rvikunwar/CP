Rudolf and the Ugly String


Rudolf has a string ğ‘  of length ğ‘›. Rudolf considers the string ğ‘  to be ugly if it contains the substringâ€  "pie" or the substring "map", otherwise the string ğ‘  will be considered beautiful.

For example, "ppiee", "mmap", "dfpiefghmap" are ugly strings, while "mathp", "ppiiee" are beautiful strings.

Rudolf wants to shorten the string ğ‘  by removing some characters to make it beautiful.

The main character doesn't like to strain, so he asks you to make the string beautiful by removing the minimum number of characters. He can remove characters from any positions in the string (not just from the beginning or end of the string).

â€  String ğ‘ is a substring of ğ‘ if there exists a consecutive segment of characters in string ğ‘ equal to ğ‘.

Input
The first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤104) â€” the number of test cases. The descriptions of the test cases follow.

The first line of each test case contains a single integer ğ‘› (1â‰¤ğ‘›â‰¤106) â€” the length of the string ğ‘ .

The next line of each test case contains the string ğ‘  of length ğ‘›. The string ğ‘  consists of lowercase Latin letters.

The sum of ğ‘› over all test cases does not exceed 106.

Output
For each test case, output a single integer â€” the minimum number of characters that need to be deleted to make the string ğ‘  beautiful. If the string is initially beautiful, then output 0.



#include <bits/stdc++.h>
using namespace std;

vector<int> computeLPSArray(string pat, int M)
{
    vector<int> lps(M);
    int len = 0;
    lps[0] = 0;
 
    int i = 1;
    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        }
        else 
        {
            if (len != 0) {
                len = lps[len - 1];
            }
            {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

vector<int> KMPSearch(string pat, string txt){
    int M = pat.size();
    int N = txt.size();
    vector<int> ans(N, 0);
 
    vector<int> lps = computeLPSArray(pat, M);
 
    int i = 0;
    int j = 0; 
    while ((N - i) >= (M - j)) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }
 
        if (j == M) {
            ans[i-j] = 1;
            j = lps[j - 1];
        }
 
        else if (i < N && pat[j] != txt[i]) {
            if (j != 0)
                j = lps[j - 1];
            else
                i = i + 1;
        }
    }
    return ans;
}

int main() {

    int t;
    cin>>t;
    while(t--){
        string s;
        int n;
        cin>>n;
        string pie = "pie";
        string map = "map";
        cin>>s;
        vector<int> mapM = KMPSearch(map, s);
        vector<int> pieM = KMPSearch(pie, s);

        int ans = 0; 
        for(int i=0; i<n; i++){
            if(mapM[i] == 1){
                ans++;
            }
            if(pieM[i] == 1){
                if((i-2)>=0 && mapM[i-2] == 1){
                    continue;
                } else {
                    ans++;
                }
            }

        }
        cout<<ans<<endl;
    }
    return 0;
    
}