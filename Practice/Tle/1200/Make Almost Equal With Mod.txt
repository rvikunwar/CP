Make Almost Equal With Mod

â €
You are given an array ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› of distinct positive integers. You have to do the following operation exactly once:

choose a positive integer ğ‘˜;
for each ğ‘– from 1 to ğ‘›, replace ğ‘ğ‘– with ğ‘ğ‘– mod ğ‘˜â€ .
Find a value of ğ‘˜ such that 1â‰¤ğ‘˜â‰¤1018 and the array ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› contains exactly 2 distinct values at the end of the operation. It can be shown that, under the constraints of the problem, at least one such ğ‘˜ always exists. If there are multiple solutions, you can print any of them.

â€  ğ‘ mod ğ‘ denotes the remainder after dividing ğ‘ by ğ‘. For example:

7 mod 3=1 since 7=3â‹…2+1
15 mod 4=3 since 15=4â‹…3+3
21 mod 1=0 since 21=21â‹…1+0
Input
Each test contains multiple test cases. The first line contains the number of test cases ğ‘¡ (1â‰¤ğ‘¡â‰¤500). The description of the test cases follows.

The first line of each test case contains a single integer ğ‘› (2â‰¤ğ‘›â‰¤100) â€” the length of the array ğ‘.

The second line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤1017) â€” the initial state of the array. It is guaranteed that all the ğ‘ğ‘– are distinct.

Note that there are no constraints on the sum of ğ‘› over all test cases.

Output
For each test case, output a single integer: a value of ğ‘˜ (1â‰¤ğ‘˜â‰¤1018) such that the array ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› contains exactly 2 distinct values at the end of the operation.

#include <bits/stdc++.h>
using namespace std;


int main() {

    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;

        vector<long long> vc(n);

        for(int i=0; i<n; i++){
            cin>>vc[i];
        }

        long long res = 2;

        while(1){
            set<long long> s;
            for(int i=0; i<n; i++){
                s.insert(vc[i] % res);
            }

            if(s.size() == 2){
                break;
            }
            res = res << 1;
        }
        cout<<res<<endl;
    }

    return 0;
    
}